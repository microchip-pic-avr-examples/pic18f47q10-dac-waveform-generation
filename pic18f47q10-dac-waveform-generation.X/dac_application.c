/**
 dac_application.c for application functionalities.
 
  @Company
    Microchip Technology Inc.
 
  @File Name
    dac_application.c
 
  @Summary
    This source file contains functions to generate four different waves.  
 
  @Description
    This source file provides implementations for wave generation APIs. 
 */
/*
© [2023] Microchip Technology Inc. and its subsidiaries.

    Subject to your compliance with these terms, you may use Microchip 
    software and any derivatives exclusively with Microchip products. 
    You are responsible for complying with 3rd party license terms  
    applicable to your use of 3rd party software (including open source  
    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
    THIS SOFTWARE.
*/
#include "mcc_generated_files/system/system.h"
#include "dac_application.h"

#define SET (1)
#define CLEAR (0)
#define POINTS (128)                //Number of Inputs in array
#define REFERENCE_VOL1 (0x10)       //Digital value for 1.6V
#define REFERENCE_VOL2 (0x1d)       //Digital value for 3V
#define MAX_WAVE_COUNT (5)          //Number of functionality 3 signals + 2 reference voltage  


volatile uint8_t dacUpdateFlag = CLEAR;
volatile uint8_t changeWaveformFlag = CLEAR;
uint8_t index = POINTS;
uint8_t swcnt; //variable to handle the interrupt counts for update the signal switch
uint8_t *LUT_ptr; //Pointer to feed the input to DAC1

// array to generate the sine wave signal of 250 HZ, 3.3V peak to peak
const uint8_t sineLUT[] = {
    0x10, 0x10, 0x11, 0x12, 0x13, 0x13, 0x14, 0x15,
    0x15, 0x16, 0x17, 0x17, 0x18, 0x19, 0x19, 0x1a,
    0x1a, 0x1b, 0x1b, 0x1c, 0x1c, 0x1d, 0x1d, 0x1e,
    0x1e, 0x1e, 0x1e, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
    0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1e, 0x1e,
    0x1e, 0x1e, 0x1d, 0x1d, 0x1c, 0x1c, 0x1b, 0x1b,
    0x1a, 0x1a, 0x19, 0x19, 0x18, 0x17, 0x17, 0x16,
    0x15, 0x15, 0x14, 0x13, 0x13, 0x12, 0x11, 0x10,
    0x10, 0xf, 0xe, 0xd, 0xc, 0xc, 0xb, 0xa,
    0xa, 0x9, 0x8, 0x8, 0x7, 0x6, 0x6, 0x5,
    0x5, 0x4, 0x4, 0x3, 0x3, 0x2, 0x2, 0x1,
    0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1,
    0x1, 0x1, 0x2, 0x2, 0x3, 0x3, 0x4, 0x4,
    0x5, 0x5, 0x6, 0x6, 0x7, 0x8, 0x8, 0x9,
    0xa, 0xa, 0xb, 0xc, 0xc, 0xd, 0xe, 0xf
};

// array to generate the square wave signal of 250 HZ, 3.3V peak to peak
const uint8_t squareLUT[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
    0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
    0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
    0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
    0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
    0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
    0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
    0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f
};

//array to generate the triangle wave of 250 HZ, 3.3V peak to peak
const uint8_t triangleLUT[] = {
    0x0, 0x1, 0x1, 0x2, 0x2, 0x3, 0x3, 0x4,
    0x4, 0x5, 0x5, 0x6, 0x6, 0x7, 0x7, 0x8,
    0x8, 0x9, 0x9, 0xa, 0xa, 0xb, 0xb, 0xc,
    0xc, 0xd, 0xd, 0xe, 0xe, 0xf, 0xf, 0x10,
    0x10, 0x10, 0x11, 0x11, 0x12, 0x12, 0x13, 0x13,
    0x14, 0x14, 0x15, 0x15, 0x16, 0x16, 0x17, 0x17,
    0x18, 0x18, 0x19, 0x19, 0x1a, 0x1a, 0x1b, 0x1b,
    0x1c, 0x1c, 0x1d, 0x1d, 0x1e, 0x1e, 0x1f, 0x1f,
    0x1f, 0x1e, 0x1e, 0x1d, 0x1d, 0x1c, 0x1c, 0x1b,
    0x1b, 0x1a, 0x1a, 0x19, 0x19, 0x18, 0x18, 0x17,
    0x17, 0x16, 0x16, 0x15, 0x15, 0x14, 0x14, 0x13,
    0x13, 0x12, 0x12, 0x11, 0x11, 0x10, 0x10, 0x10,
    0xf, 0xf, 0xe, 0xe, 0xd, 0xd, 0xc, 0xc,
    0xb, 0xb, 0xa, 0xa, 0x9, 0x9, 0x8, 0x8,
    0x7, 0x7, 0x6, 0x6, 0x5, 0x5, 0x4, 0x4,
    0x3, 0x3, 0x2, 0x2, 0x1, 0x1, 0x0, 0x0
};

//array to generate the sawtooth wave of 250 HZ, 3.3V peak to peak
const uint8_t sawtoothLUT[] = {
    0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01,
    0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03,
    0x04, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05,
    0x06, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07,
    0x08, 0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x09,
    0x0a, 0x0a, 0x0a, 0x0a, 0x0b, 0x0b, 0x0b, 0x0b,
    0x0c, 0x0c, 0x0c, 0x0c, 0x0d, 0x0d, 0x0d, 0x0d,
    0x0e, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f, 0x0f, 0x0f,
    0x10, 0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11,
    0x12, 0x12, 0x12, 0x12, 0x13, 0x13, 0x13, 0x13,
    0x14, 0x14, 0x14, 0x14, 0x15, 0x15, 0x15, 0x15,
    0x16, 0x16, 0x16, 0x16, 0x17, 0x17, 0x17, 0x17,
    0x18, 0x18, 0x18, 0x18, 0x19, 0x19, 0x19, 0x19,
    0x1a, 0x1a, 0x1a, 0x1a, 0x1b, 0x1b, 0x1b, 0x1b,
    0x1c, 0x1c, 0x1c, 0x1c, 0x1d, 0x1d, 0x1d, 0x1d,
    0x1e, 0x1e, 0x1e, 0x1e, 0x1f, 0x1f, 0x1f, 0x1f
};

const uint8_t setRefVol1[] = {REFERENCE_VOL1};
const uint8_t setRefVol2[] = {REFERENCE_VOL2};

const uint8_t defaultLUT[] = {0x1f};

const uint8_t *signals[] = {
    setRefVol1,
    setRefVol2,
    sineLUT,
    triangleLUT,
    squareLUT,
    sawtoothLUT,
    defaultLUT
};

//enum for waveform format
typedef enum  {
    REF_VOLTAGE_1,
    REF_VOLTAGE_2,
    SINE_WAVE,
    TRIANGULAR_WAVE,
    SQUARE_WAVE,
    SAWTOOTH_WAVE 
}e_signal;

void ChangeWave(void);    
void UpdateDac(void);

/**
  @Summary
    Generate signal using DAC1.

  @Description
    This routine call the signal switching routine 
 and this routine feed the input digital data in to DAC1 for generate the switched signal 

  @Preconditions
    The WaveGenerator() routine should be called
    prior to use this routine.

  @Param
    inputData - void.

  @Returns
    None

 */
void WaveGenerator(void)
{
    if (changeWaveformFlag == SET)
    {
        ChangeWave();
        changeWaveformFlag = CLEAR;
    }
    
    switch (swcnt)
    {
        case REF_VOLTAGE_1:
            DAC1_SetOutput(*LUT_ptr);// set constant output
            break;
        case REF_VOLTAGE_2:
            DAC1_SetOutput(*LUT_ptr);// set constant output
            break;
        case SINE_WAVE:
            UpdateDac();
            break;
        case TRIANGULAR_WAVE:
            UpdateDac();
            break;
        case SQUARE_WAVE:
            UpdateDac();
            break;
        case SAWTOOTH_WAVE:
            UpdateDac();
            break;
        default:
            DAC1_SetOutput(REFERENCE_VOL1);// set constant output
            break;                    
    }
}

/*
  @Description
    Check if its time to change the DAC output for number of points to generate different waveforms and increment the LUT pointer
  @Preconditions
    None
  @Param
    None
  @Returns
    None      
*/
void UpdateDac(void)
{
    //change the DAC out periodically for number of points to generate different waveforms
    //sine, triangular, sawtooth etc. according to the lookup table
    // the period of the timer and number of points in the waveform will determine the frequency of the generated waveform
    if (dacUpdateFlag == SET)
    {        
        DAC1_SetOutput(*LUT_ptr++);
        index --;
        if (index <= 0  )
        {
            index = POINTS;
            LUT_ptr = (uint8_t *)signals[swcnt];
        }
        dacUpdateFlag = CLEAR;
    }
} 

/**
   @Description
  Switch the signals from one signal to another after switch press event 
  @Preconditions
    The changeWaveformFlag should be set prior to use this routine.
  @Param
    None
  @Returns
    None
 */
void ChangeWave(void) 
{
    LED_Toggle();
    if (swcnt < MAX_WAVE_COUNT) 
    {
        swcnt++; //Updating the switch count for changing to next waveform         
    }
    else 
    {
        swcnt = 0;// point to the first waveform to be generated   
    }
    LUT_ptr = (uint8_t *)signals[swcnt]; // LUT pointer = first point in the LUT of corresponding signal
    index = POINTS; // initialize to number of points in the waveform
}

/*
  @Description
   Initialize LUT pointer for generating first waveform at power up
  @Preconditions
    None
  @Param
    None
  @Returns
    None      
 */  
void InitWaveform(void) 
{
    LUT_ptr = (uint8_t *)signals[0];    
}

/*
  @Description
    Custom user interrupt handler routine for IOC on switch press
  @Preconditions
    None
  @Param
    None
  @Returns
    None      
 */
void UserInterruptHandler(void) 
{
    changeWaveformFlag = SET;   
}

/*
  @Description
    Interrupt handler routine for timer overflow
  @Preconditions
    None
  @Param
    None
  @Returns
    None      
 */
void TmrUserInterruptHandler(void) 
{
    //the period of the timer and number of points in the waveform will determine the frequency of the generated waveform
    dacUpdateFlag = SET;
}

